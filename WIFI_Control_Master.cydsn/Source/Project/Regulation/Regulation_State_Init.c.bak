//********************************************************************************
/*!
\author     Kraemer E.
\date       05.02.2019

\file       Regulation.c
\brief      Functionality for the regulation

***********************************************************************************/
#include "Regulation.h"
#include "ErrorDetection.h"
#include "EventManager.h"
#include "ErrorDebouncer.h"
#include "ErrorHandler.h"
#include "Aom_Regulation.h"
#include "Aom_Flash.h"
#include "Aom_Measure.h"
#include "Regulation_Data.h"


/****************************************** Defines ******************************************************/
/****************************************** Function prototypes ******************************************/
static void StateEntry(void);
static void StateActive(void);
static void StateExit(void);
static void StateOff(void);

/****************************************** Variables ****************************************************/
static u16 uiOldVoltageValue[DRIVE_OUTPUTS];
static u8 ucVoltageChangedCnt[DRIVE_OUTPUTS] = {3, 3, 3};

static tsRegulationHandler* psRegHandler = NULL;

static teSubState eSubState[DRIVE_OUTPUTS];

tCStateDefinition sRegulationStateFn = 
{
    .pFctOff = StateOff,
    .pFctEntry = StateEntry,
    .pFctActive = StateActive,
    .pFctExit = StateExit
};
/****************************************** loacl functiones *********************************************/

//********************************************************************************
/*!
\author  KraemerE
\date    18.02.2019
\brief   Enter function of the standby process. In this module all necessary
         system related peripherals should be switched off.
\param   none
\return  none
***********************************************************************************/
static void StateEntry(void)
{
    /* Change actual state */
    psRegHandler->sRegState.eRegulationState = eStateEntry;

    bool bErrorFound = false;
    
    /***** Enable regulation modules *****/      
    if(psRegHandler->bHardwareEnabled == false)
    {       
        /* Start PWM module */
        sPwmMap[psRegHandler->ucOutputIdx].pfnStart();
        
        /* Check PWM output for a fault */
        bErrorFound = ErrorDetection_CheckPwmOutput();
        
        if(bErrorFound == false)
        {
            /* Enable PWM module with lowest brightness level */
            sPwmMap[psRegHandler->ucOutputIdx].pfnWriteCompare(sPwmMap[psRegHandler->ucOutputIdx].uiPeriodVal);
            
            //Enable delay for smoother dimming
            CyDelay(10);
            
            psRegHandler->bHardwareEnabled = true;
        }
    }
    
    /* Set the regulation values for this state */
    psRegHandler->sRegAdcVal.uiReqValue = 0;

    psRegHandler->sRegAdcVal.uiIsValue = Aom_Measure_GetAdcIsValue(eMeasureChVoltage, psRegHandler->ucOutputIdx);
    
    if(bErrorFound == false)
        psRegHandler->sRegState.bStateReached = true;
}

//********************************************************************************
/*!
\author  KraemerE
\date    18.02.2019
\brief   In this state the CPU shall only wait for a message from the UIM,
         do some self-tests and maybe go to sleep.
\param   none
\return  none
***********************************************************************************/
static void StateActive(void)
{
    /* Change actual state */
    psRegHandler->sRegState.eRegulationState = eStateActiveR;
           
    u16 uiCurrentAdc = Aom_Measure_GetAdcIsValue(eMeasureChCurrent, psRegHandler->ucOutputIdx);
    u16 uiVoltageAdc = Aom_Measure_GetAdcIsValue(eMeasureChVoltage, psRegHandler->ucOutputIdx);
    
    switch(eSubState[psRegHandler->ucOutputIdx])
    {
        case eSubMinInit:
        {
            /* The first current flow is the low limit */
            if(uiCurrentAdc)
            {
                /* Save settings in AOM */
                Aom_Regulation_SetMinSystemSettings(uiCurrentAdc, uiVoltageAdc, sPwmMap[psRegHandler->ucOutputIdx].pfnReadCompare(), psRegHandler->ucOutputIdx);
                
                /* Change to next state */
                eSubState[psRegHandler->ucOutputIdx] = eSubMaxInit;
                
                /* Clear old voltage value */
                uiOldVoltageValue[psRegHandler->ucOutputIdx] = 0;
            }
            else
            {
                /* While the max voltage ADC value isn't reached, increment the requested value */
                if(psRegHandler->sRegAdcVal.uiReqValue < ADC_MAX_VAL)
                {
                    psRegHandler->sRegAdcVal.uiReqValue += Aom_Measure_GetAdcVoltageStepValue();
                }
                else
                {
                    /* Limit reached which means no load available */
                    ErrorDebouncer_PutErrorInQueue(eLoadMissingFault);
                }                
            }
            break;
        }
        
        case eSubMaxInit:
        {
            /* When the new voltage value doesn't really changes anymore a saturation is reached */
            if((uiOldVoltageValue[psRegHandler->ucOutputIdx] + Aom_Measure_GetAdcVoltageStepValue()) <= uiVoltageAdc)
            {
                if(ucVoltageChangedCnt[psRegHandler->ucOutputIdx] < 3)
                    ++ucVoltageChangedCnt[psRegHandler->ucOutputIdx];
                
                /* Save new value for next comparison */
                uiOldVoltageValue[psRegHandler->ucOutputIdx] = uiVoltageAdc;
            }
            else
            {
                --ucVoltageChangedCnt[psRegHandler->ucOutputIdx];
            }
            
            
            /* Increment the requested value until the current limit or the voltage limit is reached */
            if(uiCurrentAdc > Aom_Measure_GetAdcCurrentLimitValue() 
                || ucVoltageChangedCnt[psRegHandler->ucOutputIdx] == 0)
            {
                /* limit reached */
                Aom_Regulation_SetMaxSystemSettings(uiCurrentAdc, uiVoltageAdc, sPwmMap[psRegHandler->ucOutputIdx].pfnReadCompare(), psRegHandler->ucOutputIdx);
                
                /* Change to next state */
                eSubState[psRegHandler->ucOutputIdx] = eSubDone;
            }
            else
            {
                psRegHandler->sRegAdcVal.uiReqValue += Aom_Measure_GetAdcVoltageStepValue();
            }            
            break;   
        }
        
        case eSubDone:
        {
            /* Wait for all outputs to be done */
            u8 ucDoneCnt = 0;
            
            u8 ucIdx;
            for(ucIdx = 0; ucIdx < DRIVE_OUTPUTS; ucIdx++)
            {
                if(eSubState[psRegHandler->ucOutputIdx] == eSubDone)
                {
                    ++ucDoneCnt;
                }
            }
            
            if(ucDoneCnt == DRIVE_OUTPUTS)
            {
                /* Save values in flash */
                Aom_Flash_WriteSystemSettingsInFlash();
                
                /* Post event to inform GUI */
                EVT_PostEvent(eEvtInitRegulationValue, eEvtParam_InitRegulationDone, 0);
            }
            
            /* When done set to user requested value */
            #warning what to do?
            //psRegHandler->sRegAdcVal.uiReqValue = Aom_Measure_GetAdcRequestedValue(ucOutputIdx);
            
            psRegHandler->sRegState.bStateReached = true;
            psRegHandler->sRegAdcVal.bInitialized = true;
            break;
        }
    }
}

//********************************************************************************
/*!
\author  KraemerE
\date    18.02.2019
\brief   This state re-enables the low voltage peripherals to measure the temperature.
         After some measurements the state is leaved and entered via "StateEntryLowVoltage"
         or when the standby should be left the "StateExitSystem".
\param   none
\return  none
***********************************************************************************/
static void StateExit(void)
{    
    /* Change actual state */
    psRegHandler->sRegState.eRegulationState = eStateExit;
    
    /* Set the regulation values for this state */
    Aom_Measure_GetMinMaxAdcValues(&psRegHandler->sRegAdcVal.uiReqValue, NULL, psRegHandler->ucOutputIdx);       
    psRegHandler->sRegAdcVal.uiIsValue = Aom_Measure_GetAdcIsValue(eMeasureChVoltage,psRegHandler->ucOutputIdx);    
    
    //Dimm down until lowest possible value is reached
    if((psRegHandler->sRegAdcVal.uiReqValue == psRegHandler->sRegAdcVal.uiIsValue)
        || psRegHandler->sRegAdcVal.bCantReach)
    {
        psRegHandler->sRegState.bStateReached = true;
    }
}


//********************************************************************************
/*!
\author  KraemerE
\date    18.02.2019
\brief   This state is called when the PCM temperature is above the set limit or
         the UIM requested to leave the stand by mode.
\param   none
\return  none
***********************************************************************************/
static void StateOff(void)
{
    /* Change actual state */
    psRegHandler->sRegState.eRegulationState = eStateOff;
    
    /***** Disable regulation module ****/    
    if(psRegHandler->bHardwareEnabled == true)
    {       
        /* Wait a short time */
        CyDelay(10);

        sPwmMap[psRegHandler->ucOutputIdx].pfnStop();
        
        psRegHandler->bHardwareEnabled = false;
    }
    
    psRegHandler->sRegState.bStateReached = true;
}

/****************************************** External visible functiones **********************************/
//********************************************************************************
/*!
\author  KraemerE
\date    06.11.2020
\brief   Links the regulation module with this state module together
\param   psRegulationHandler - Pointer to the regulation handler structure of the
                               regulation module
\return  tCStateDefinition* - Either the address of this regulation function module or null
***********************************************************************************/
tCStateDefinition* Regulation_State_InitLink(tsRegulationHandler* psRegulationHandler)
{    
    /* Check for valid pointer */
    if(psRegulationHandler)
    {
        /* Link the regulation handler together */
        psRegHandler = psRegHandler;
        
        /* Set substate to init min state */
        u8 ucDriveIdx;
        for(ucDriveIdx = 0; ucDriveIdx < DRIVE_OUTPUTS; ucDriveIdx++)
        {
            eSubState[ucDriveIdx] = eSubMinInit;
        }
        
        /* Return the correct state function pointers */
        return &sRegulationStateFn;
    }
    else
    {
        return NULL;
    }
}